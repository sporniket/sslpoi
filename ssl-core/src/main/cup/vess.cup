// CUP specification for VErbose SpornyScript (vess)
// [FIXME] for now use a sample spec to get the build up and running.
// CUP specification for a simple expression evaluator (w/ actions)

import java_cup.runtime.*;
import com.sporniket.scripting.ssl.mass.*;

//Define a MASS TreeBuilder with accessor. it must be defined before parsing.
action code {:
	public TreeBuilder getTreeBuilder() {return parser.getTreeBuilder() ;}
:}

parser code {:
	private TreeBuilder myTreeBuilder;
	
	public TreeBuilder getTreeBuilder() {return myTreeBuilder ;}
	public void setTreeBuilder(TreeBuilder treeBuilder) {myTreeBuilder = treeBuilder;}	
:}

/* Terminals (tokens returned by the scanner). */
terminal           DEFINE, AS, NEW;
terminal           IDENTIFIER, PACKAGEPREFIX;
//terminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD;
//terminal           UMINUS, LPAREN, RPAREN;
//terminal Integer   NUMBER;

/* Non-terminals */
non terminal            statm__list, statm__single ;
non terminal            statm_define ;
non terminal            expr_classname;
//non terminal            expr_list, expr_part;
//non terminal Integer    expr;

/* Precedences */
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE, MOD;
//precedence left UMINUS;

//======== GRAMMAR ========
//==== Statements break down ====
statm__list 
	::= 
		statm__single statm__list
	|
		statm__single
	;

statm__single
	::=
		statm_define
	;

//==== Statement types ====
statm_define 
	::= 
		DEFINE IDENTIFIER:id AS NEW expr_classname:cls {: getTreeBuilder().add(new StatementDefineAs((String)id, StatementDefineAs.InitialisationMode.NEW, (String)cls)); RESULT = id; :}
	;

//==== Expressions ====
expr_classname 
	::= 
		PACKAGEPREFIX:pack IDENTIFIER:cls {: RESULT = ((String)pack)+((String)cls) ; :}
	|
		IDENTIFIER:cls {: RESULT = cls ; :} 
	;
/*
expr_list ::= expr_list expr_part 
	      | 
              expr_part;

expr_part ::= expr:e 
	      {: System.out.println("= " + e); :} 
              SEMI              
	      ;

expr      ::= expr:e1 PLUS expr:e2    
	      {: RESULT = new Integer(e1.intValue() + e2.intValue()); :} 
	      | 
              expr:e1 MINUS expr:e2    
              {: RESULT = new Integer(e1.intValue() - e2.intValue()); :} 
	      | 
              expr:e1 TIMES expr:e2 
	      {: RESULT = new Integer(e1.intValue() * e2.intValue()); :} 
	      | 
              expr:e1 DIVIDE expr:e2 
	      {: RESULT = new Integer(e1.intValue() / e2.intValue()); :} 
	      | 
              expr:e1 MOD expr:e2 
	      {: RESULT = new Integer(e1.intValue() % e2.intValue()); :} 
	      | 
              NUMBER:n                 
	      {: RESULT = n; :} 
	      | 
              MINUS expr:e             
	      {: RESULT = new Integer(0 - e.intValue()); :} 
	      %prec UMINUS
	      | 
              LPAREN expr:e RPAREN     
	      {: RESULT = e; :} 
	      ;
*/
