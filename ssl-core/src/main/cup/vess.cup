// CUP specification for VErbose SpornyScript (vess)
// [FIXME] for now use a sample spec to get the build up and running.
// CUP specification for a simple expression evaluator (w/ actions)

import java_cup.runtime.*;
import com.sporniket.scripting.ssl.core.*;
import com.sporniket.scripting.ssl.mass.*;

/* Terminals (tokens returned by the scanner). */
terminal           DEFINE, AS, NEW;
terminal           CALL, USING, FROM, COMMA;
terminal           IDENTIFIER, PACKAGEPREFIX;
//terminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD;
//terminal           UMINUS, LPAREN, RPAREN;
//terminal Integer   NUMBER;

/* Non-terminals */
non terminal            statm__list, statm__single ;
non terminal            statm_call, statm_define ;
non terminal            part_using,part_using__list,part_using__single ;
non terminal            expr_classname,expr_from,expr_methodname,expr_value;
//non terminal            expr_list, expr_part;
//non terminal Integer    expr;

/* Precedences */
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE, MOD;
//precedence left UMINUS;

//======== GRAMMAR ========
//==== Statements break down ====
statm__list 
	::= 
		statm__single:statm statm__list:other {: ((VessNode) statm).setNext((VessNode) other) ; RESULT = statm ; :} 
	|
		statm__single:statm {: RESULT = statm ; :}
	;

statm__single
	::=
		statm_call:statm {: RESULT = statm ; :}
	|
		statm_define:statm {: RESULT = statm ; :}
	;

//==== Statement types ====
statm_call
	::=
		CALL expr_methodname:meth part_using:using /*treebuilder->add call(node meth, node using)*/
	|
		CALL expr_methodname:meth /*treebuilder->add call(node meth)*/
	;

statm_define 
	::= 
		DEFINE IDENTIFIER:id AS NEW expr_classname:cls {: RESULT = new VessNodeDefineAs((String)id, InitialisationMode.NEW, (String)cls) ; :}
	;

//== Statement parts ==
part_using
	::=
		USING part_using__list /*treebuilder->commit list 'using'*/
	;

part_using__list
	::=
		part_using__single COMMA part_using__list
	|
		part_using__single
	;

part_using__single
	::=
		expr_value:val AS IDENTIFIER:id /*treebuilder->push (id,val) in list 'using'*/
	;

//==== Expressions ====
expr_classname 
	::= 
		PACKAGEPREFIX:pack IDENTIFIER:cls {: RESULT = ((String)pack)+((String)cls) ; :}
	|
		IDENTIFIER:cls {: RESULT = cls ; :} 
	;

expr_from
	::=
		FROM IDENTIFIER:id expr_from:from /*treebuilder->expressionBinaryNode('from',from,id)*/
	|
		FROM IDENTIFIER:id /*treebuilder->expressionLeafNode('identifier',id)*/
	;
	
expr_methodname
	::=
		IDENTIFIER:id expr_from:from /*treebuilder->expressionBinaryNode('from',from,id)*/
	;
	
expr_value
	::=
		IDENTIFIER:id /*treebuilder->expressionLeafNode('identifier',id)*/
	;
/*
expr_list ::= expr_list expr_part 
	      | 
              expr_part;

expr_part ::= expr:e 
	      {: System.out.println("= " + e); :} 
              SEMI              
	      ;

expr      ::= expr:e1 PLUS expr:e2    
	      {: RESULT = new Integer(e1.intValue() + e2.intValue()); :} 
	      | 
              expr:e1 MINUS expr:e2    
              {: RESULT = new Integer(e1.intValue() - e2.intValue()); :} 
	      | 
              expr:e1 TIMES expr:e2 
	      {: RESULT = new Integer(e1.intValue() * e2.intValue()); :} 
	      | 
              expr:e1 DIVIDE expr:e2 
	      {: RESULT = new Integer(e1.intValue() / e2.intValue()); :} 
	      | 
              expr:e1 MOD expr:e2 
	      {: RESULT = new Integer(e1.intValue() % e2.intValue()); :} 
	      | 
              NUMBER:n                 
	      {: RESULT = n; :} 
	      | 
              MINUS expr:e             
	      {: RESULT = new Integer(0 - e.intValue()); :} 
	      %prec UMINUS
	      | 
              LPAREN expr:e RPAREN     
	      {: RESULT = e; :} 
	      ;
*/
