// CUP specification for VErbose SpornyScript (vess)
// [FIXME] for now use a sample spec to get the build up and running.
// CUP specification for a simple expression evaluator (w/ actions)

import java_cup.runtime.*;
import com.sporniket.scripting.ssl.core.*;
import com.sporniket.scripting.ssl.mass.*;

/* Terminals (tokens returned by the scanner). */
terminal           DEFINE, AS, NEW;
terminal           CALL, USING, FROM, COMMA;
terminal           IDENTIFIER, PACKAGEPREFIX;
//terminal           SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD;
//terminal           UMINUS, LPAREN, RPAREN;
//terminal Integer   NUMBER;

/* Non-terminals */
non terminal            statm__list, statm__single ;
non terminal            statm_call, statm_define ;
non terminal            part_using__list,part_using__single ;
non terminal            expr_access_stack;
non terminal            expr_classname,expr_from,expr_methodname,expr_value;
//non terminal            expr_list, expr_part;
//non terminal Integer    expr;

/* Precedences */
//precedence left PLUS, MINUS;
//precedence left TIMES, DIVIDE, MOD;
//precedence left UMINUS;

//======== GRAMMAR ========
//==== Statements break down ====
statm__list 
	::= 
		statm__single:statm statm__list:other {: ((VessNode) statm).setNext((VessNode) other) ; RESULT = statm ; :} 
	|
		statm__single:statm {: RESULT = statm ; :}
	;

statm__single
	::=
		statm_call:statm {: RESULT = statm ; :}
	|
		statm_define:statm {: RESULT = statm ; :}
	;

//==== Statement types ====
statm_call
	::=
		CALL expr_methodname:meth USING part_using__list:using
		{:
			RESULT = new VessNodeCall().withCall((VessNodeAccessor)meth).withMapping((VessNodeArgumentMapping) using) ;
		:}
	|
		CALL expr_methodname:meth
		{:
			RESULT = new VessNodeCall().withCall((VessNodeAccessor)meth) ;
		:}
	;

statm_define 
	::= 
		DEFINE IDENTIFIER:id AS NEW expr_classname:cls {: RESULT = new VessNodeDefineAs((String)id, InitialisationMode.NEW, (String)cls) ; :}
	;

//== Statement parts ==
part_using__list
	::=
		part_using__single:single COMMA part_using__list:list
		{:
			RESULT = ((VessNode)single).withNext((VessNode)list);
		:}
	|
		part_using__single:single
		{:
			RESULT = single ;
		:}
	;

part_using__single
	::=
		expr_value:val AS IDENTIFIER:id
		{:
			RESULT = new VessNodeArgumentMapping().withName((String)id).withValue((VessNode)val);
		:}
	;

//==== Expressions ====
expr_classname 
	::= 
		PACKAGEPREFIX:pack IDENTIFIER:cls {: RESULT = ((String)pack)+((String)cls) ; :}
	|
		IDENTIFIER:cls {: RESULT = cls ; :} 
	;

expr_from
	::=
		FROM IDENTIFIER:id expr_from:from 
		{: 
			VessNodeAccessor _node = new VessNodeAccessor().withValue((String)id);
			if (null!=from)
			{
				RESULT = ((VessNode)from).withNext(_node);
			}
			else
			{
				RESULT = _node ;
			}
		:}
	|
		FROM IDENTIFIER:id 
		{:
			RESULT = new VessNodeAccessor().withValue((String)id);
		:}
	;
	
expr_access_stack
	::=
		IDENTIFIER:id expr_from:from 
		{: 
			VessNodeAccessor _node = new VessNodeAccessor().withValue((String)id);
			if (null!=from)
			{
				RESULT = ((VessNode)from).withNext(_node);
			}
			else
			{
				RESULT = _node ;
			}
		:}
	;

expr_methodname
	::=
		expr_access_stack:stack
		{:
			RESULT = stack ;
		:}
	;
		
	
expr_value
	::=
		expr_access_stack:stack
		{:
			RESULT = stack ;
		:}
	;
/*
expr_list ::= expr_list expr_part 
	      | 
              expr_part;

expr_part ::= expr:e 
	      {: System.out.println("= " + e); :} 
              SEMI              
	      ;

expr      ::= expr:e1 PLUS expr:e2    
	      {: RESULT = new Integer(e1.intValue() + e2.intValue()); :} 
	      | 
              expr:e1 MINUS expr:e2    
              {: RESULT = new Integer(e1.intValue() - e2.intValue()); :} 
	      | 
              expr:e1 TIMES expr:e2 
	      {: RESULT = new Integer(e1.intValue() * e2.intValue()); :} 
	      | 
              expr:e1 DIVIDE expr:e2 
	      {: RESULT = new Integer(e1.intValue() / e2.intValue()); :} 
	      | 
              expr:e1 MOD expr:e2 
	      {: RESULT = new Integer(e1.intValue() % e2.intValue()); :} 
	      | 
              NUMBER:n                 
	      {: RESULT = n; :} 
	      | 
              MINUS expr:e             
	      {: RESULT = new Integer(0 - e.intValue()); :} 
	      %prec UMINUS
	      | 
              LPAREN expr:e RPAREN     
	      {: RESULT = e; :} 
	      ;
*/
